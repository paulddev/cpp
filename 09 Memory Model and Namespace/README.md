# 메모리 모델과 이름 공간
- 분할 컴파일
- 위치 지정 new
- 기억 존속 시간, 사용 범위, 링크
- 이름 공간

C++ 에서는 메모리에 데이터를 여러 가지 방법으로 저장할 수 있다. <br>
일반적으로 덩치 큰 프로그램은 데이터를 공유하는 여러 개의 소스 코드 파일들로 구성된다.

## 분할 컴파일
파일들을 개별적으로 분할하여 컴파일한 후에, 그것들을 하나의 최종 실행 프로그램으로 링크할 수 있다. <br>
만일 어떤 하나의 파일을 수정했다면, 그 파일 하나만을 다시 컴파일해서, 이미 컴파일되어 있는 다른 파일들과 `링크`하면 된다.

### 헤더 파일
- 함수 원형
- `#define`이나 `const`를 사용하여 정의하는 기호 상수
- 구조체 선언
- 클래스 선언
- 템플릿 선언
- 인라인 함수

`구조체`선언은 변수를 만들지 않기 때문에 헤더 파일에 넣어도 된다. <br>
`템플릿`선언도 컴파일되는 코드가 아니다. 소스 코드에서 발견된 함수 호출에 대응하는 함수 정의를 생성하는 방법을 컴파일러에게 지시한다. <br>

헤더 파일을 포함시킬 때 `<>`로 묶여있다면 컴파일러는 표준 헤더 파일들이 들어 있는 호스트 시스템의 파일 시스템 영역에서 찾고,
`""`로 묶여 있으면, 현재 작업 디렉토리나 소스 코드 디렉토리에서 찾는다. 사용자가 만든 헤더 파일을 포함시킬 때에는 각진 괄호 대신에 큰따옴표를 사용해야 한다.

### 헤더 파일의 관리
헤더 파일을 어떤 파일에 포함시킬 때에는 `단 한 번만 포함`시켜야 한다. 헤더 파일을 여러 번 포함시키는 실수를 저지르기가 쉽다.
C와 C++에서 헤더 파일을 여러 번 포함시키는 실수를 피하기 위해 사용하는 표준 기법이 있다.
`전처리기 지시자`인 `#ifndef(if not defined)`를 사용하는 것이다.

```cpp
#ifndef COORDIN_H_
...
#endif
```

`COORDIN_H_`라는 이름의 전처리기 지시자 `#define`에 의해 정의되어 있지 않은 경우에만, `#ifndef`와 `#endif` 사이에 있는 구문들을 처리하라는 뜻이다.

```cpp
#ifndef COORDIN_H_
#define COORDIN_H_
// 포함시킬 include 파일의 내용을 여기에 추가한다.
#endif
```

다른 곳에서 좀처럼 사용할 것 같지 않은 이름으로 만들기 위해, `밑줄`문자를 사용하는 관습이 있는 것 같다. <br>
해당 기법은 컴파일러가 한 파일을 2번 포함시키는 것을 막지는 못한다. 그 대신, 처음으로 포함시킨 것을 제외한 나머지는 컴파일러가 무시하게 만든다.
이렇게 하지 않으면 하나의 파일에 2번 정의된 동일한 구조를 얻게 될 수도 있게 되며, 이것은 컴파일 에러를 유발시킬 것이다.

