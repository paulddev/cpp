# 함수의 활용
- 인라인 함수
- 참조 변수
- 함수 매개변수를 참조로 전달
- 디폴트 매개변수
- 함수 오버로딩
- 함수 템플릿
- 함수 템플릿의 특수화


## C++ 인라인(inline) 함수

인라인 함수는 프로그램의 실행 속도를 높이기 위해 C++에서 새롭게 보강된 키워드.

### 일반 함수 vs 인라인 함수의 가장 큰 차이
C++ 컴파일러가 코드를 프로그램에 어떻게 결합하느냐에 있다.

컴파일 작업의 최종 산출물은 기계어 명령으로 이루어진 실행 프로그램.
프로그램 실행 시, 운영체제는 명령들을 컴퓨터의 메모리에 로드한다.
로드된 명령들은 각각 하나의 특정 메모리 주소를 갖게 된다.
컴퓨터는 이 명령들을 `순차적`으로 실행한다.
`루프`나 `분기문`을 만나면, 프로그램은 앞이나 뒤의 특정 주소로 점프하여 명령들을 건너뛴다.

`일반적인 함수의 호출`은 프로그램을 다른 주소(그 함수의 주소)로 점프시켰다가, 함수의 처리가 종결되면 다시 원래의 자리로 돌아온다.

	프로그램이 함수 호출 명령에 도달했을 때, 그 함수 호출 명령 바로 다음에 있는 명령의 주소를 메모리에 저장하고,
	스택에 매개변수를 복사한 후, 그 함수가 시작되는 메모리 위치로 점프한다.
	그 함수의 코드를 수행하고, 함수의 리턴값을 레지스터에 복사한 후, 저장해 두었던 주소의 명령으로 돌아온다.
	이렇게 앞뒤로 점프를 수행하고, 점프할 위치를 기억하려면 함수를 사용하는 데 시간이 많이 걸린다.

`C++ 인라인 함수`

	인라인 함수에서는 컴파일된 함수 코드가 프로그램의 다른 코드 안에 직접 삽입되어 있다.
	컴파일러가 함수 호출을 그에 대응하는 함수 코드로 대체한다는 것이다.
	대체로 인해 그 함수를 수행하기 위해 프로그램이 다른 주소로 점프했다가 돌아올 필요가 없다.
	따라서 인라인 함수는 일반 함수보다 약간 빠르게 수행된다!

	다만 메모리 사용 측면에서는 인라인 함수가 일반 함수보다 불리하다.
	어떤 프로그램에서 인라인 함수를 10번 호출한다면, 프로그램은 그 함수의 사본을 프로그램의 코드 안에 10번이나 삽입해야 한다.

	그래서 일반적으로는 함수 코드를 수행하는 데 걸리는 시간이 매우 짧은 경우에만 인라인 함수를 사용하는 것이 
	일반 함수를 사용하는 것보다 시간이 절약된다.


```cpp
함수 선언 앞에 inline 이라는 키워드를 붙인다.
함수 정의 앞에 inline 이라는 키워드를 붙인다.
```

일반적인 관행은 원형을 아예 생략하고, 원형이 놓일 자리에 함수 정의 전체를 놓는 것이다.

### 주의할 점
어떤 함수를 `인라인`으로 만들어 달라는 사용자의 요구를 컴파일러가 반드시 따르는 것이 아니다.
`함수의 덩치가 크다`는 이유로 또는 `재귀 호출`이라는 이유로 그러한 요구를 거절하는 컴파일러도 있다.
`인라인`함수는 재귀 호출이 허용되지 않는다.
컴파일러가 인라인 함수 기능을 구현하지 못할 수도 있다.


### 인라인과 매크로
인라인 기능은 `C++`에서 새로 추가된 것이다. <br>
`C`는 매크로 기능을 제공하기 위해 선행처리기 `#define` 구문을 사용한다. <br>
매크로는 인라인 코드를 소스적으로 구현한 형태다.

```c
#define SQUARE(X) ( (X) * (X) )
```

```cpp
inline double square(double x)
{
	return x * x;
}
```

## 참조 변수
`C++`은 `참조 변수`라는 새로운 복합형을 언어에 추가했다.

	참조(reference)는 미리 정의된 어떤 변수의 실제 이름 대신 쓸 수 있는 대용 이름이다.

### 참조의 주된 용도
함수의 매개변수에 사용하는 것이다. 참조를 매개변수로 사용하면, 그 함수는 복사본 대신 `원본 데이터`를 가지고 작업한다.
덩치 큰 구조체를 처리해야 하는 함수에서 `포인터` 대신 `참조`를 사용할 수 있다.
참조는 클래스를 설계할 때 필수적으로 사용된다.

### 참조 변수의 생성
```cpp
int rats;
int& rodents = rats;

&가 주소 연산자가 아니라, 데이터형 식별자의 일부로 사용된다.
이 둘은 모두 같은 값과 같은 메모리 위치를 참조한다.
```

### 참조는 포인터?
```cpp
int rats = 101;
int & rodents = rats; // rodents는 참조
int * prats = &rats;  // prats는 포인터

rodents나 *prats를 rats와 서로 바꾸어 사용할 수 있고, &rodents나 prats를 &rats와 서로 바꾸어 사용할 수 있다.
```

### 포인터와 참조 사이에는 표기 방식 외에도 차이가 존재한다.
참조를 먼저 선언하고 나중에 값을 지정할 수 없다! <br>
<mark> 참조를 선언할 때 참조 변수를 함께 초기화해야 한다. </mark> <br>
참조는 `const`포인터와 상당히 비슷하다. 참조를 만들 때 반드시 초기화를 해야하고, 어떤 특정 변수에 연결되면 그것을 고수해야 한다.
```cpp
int & rodents = rats;

int * const pr = &rats;

여기서 rodents는 *pr과 같은 역할을 한다.
```
