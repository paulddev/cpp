# 함수의 활용
- 인라인 함수
- 참조 변수
- 함수 매개변수를 참조로 전달
- 디폴트 매개변수
- 함수 오버로딩
- 함수 템플릿
- 함수 템플릿의 특수화


## C++ 인라인(inline) 함수
인라인 함수는 프로그램의 실행 속도를 높이기 위해 C++에서 새롭게 보강된 키워드.

### 일반 함수 vs 인라인 함수의 가장 큰 차이
C++ 컴파일러가 코드를 프로그램에 어떻게 결합하느냐에 있다.

컴파일 작업의 최종 산출물은 기계어 명령으로 이루어진 실행 프로그램.
프로그램 실행 시, 운영체제는 명령들을 컴퓨터의 메모리에 로드한다.
로드된 명령들은 각각 하나의 특정 메모리 주소를 갖게 된다.
컴퓨터는 이 명령들을 `순차적`으로 실행한다.
`루프`나 `분기문`을 만나면, 프로그램은 앞이나 뒤의 특정 주소로 점프하여 명령들을 건너뛴다.

`일반적인 함수의 호출`은 프로그램을 다른 주소(그 함수의 주소)로 점프시켰다가, 함수의 처리가 종결되면 다시 원래의 자리로 돌아온다.

	프로그램이 함수 호출 명령에 도달했을 때, 그 함수 호출 명령 바로 다음에 있는 명령의 주소를 메모리에 저장하고,
	스택에 매개변수를 복사한 후, 그 함수가 시작되는 메모리 위치로 점프한다.
	그 함수의 코드를 수행하고, 함수의 리턴값을 레지스터에 복사한 후, 저장해 두었던 주소의 명령으로 돌아온다.
	이렇게 앞뒤로 점프를 수행하고, 점프할 위치를 기억하려면 함수를 사용하는 데 시간이 많이 걸린다.

`C++ 인라인 함수`

	인라인 함수에서는 컴파일된 함수 코드가 프로그램의 다른 코드 안에 직접 삽입되어 있다.
	컴파일러가 함수 호출을 그에 대응하는 함수 코드로 대체한다는 것이다.
	대체로 인해 그 함수를 수행하기 위해 프로그램이 다른 주소로 점프했다가 돌아올 필요가 없다.
	따라서 인라인 함수는 일반 함수보다 약간 빠르게 수행된다!

	다만 메모리 사용 측면에서는 인라인 함수가 일반 함수보다 불리하다.
	어떤 프로그램에서 인라인 함수를 10번 호출한다면, 프로그램은 그 함수의 사본을 프로그램의 코드 안에 10번이나 삽입해야 한다.

	그래서 일반적으로는 함수 코드를 수행하는 데 걸리는 시간이 매우 짧은 경우에만 인라인 함수를 사용하는 것이 
	일반 함수를 사용하는 것보다 시간이 절약된다.


```cpp
함수 선언 앞에 inline 이라는 키워드를 붙인다.
함수 정의 앞에 inline 이라는 키워드를 붙인다.
```

일반적인 관행은 원형을 아예 생략하고, 원형이 놓일 자리에 함수 정의 전체를 놓는 것이다.

### 주의할 점
어떤 함수를 `인라인`으로 만들어 달라는 사용자의 요구를 컴파일러가 반드시 따르는 것이 아니다.
`함수의 덩치가 크다`는 이유로 또는 `재귀 호출`이라는 이유로 그러한 요구를 거절하는 컴파일러도 있다.
`인라인`함수는 재귀 호출이 허용되지 않는다.
컴파일러가 인라인 함수 기능을 구현하지 못할 수도 있다.


### 인라인과 매크로
인라인 기능은 `C++`에서 새로 추가된 것이다. <br>
`C`는 매크로 기능을 제공하기 위해 선행처리기 `#define` 구문을 사용한다. <br>
매크로는 인라인 코드를 소스적으로 구현한 형태다.

```c
#define SQUARE(X) ( (X) * (X) )
```

```cpp
inline double square(double x)
{
	return x * x;
}
```

## 참조 변수
`C++`은 `참조 변수`라는 새로운 복합형을 언어에 추가했다.

	참조(reference)는 미리 정의된 어떤 변수의 실제 이름 대신 쓸 수 있는 대용 이름이다.

### 참조의 주된 용도
함수의 매개변수에 사용하는 것이다. 참조를 매개변수로 사용하면, 그 함수는 복사본 대신 `원본 데이터`를 가지고 작업한다.
덩치 큰 구조체를 처리해야 하는 함수에서 `포인터` 대신 `참조`를 사용할 수 있다.
참조는 클래스를 설계할 때 필수적으로 사용된다.

### 참조 변수의 생성
```cpp
int rats;
int& rodents = rats;

&가 주소 연산자가 아니라, 데이터형 식별자의 일부로 사용된다.
이 둘은 모두 같은 값과 같은 메모리 위치를 참조한다.
```

### 참조는 포인터? (X)
```cpp
int rats = 101;
int & rodents = rats; // rodents는 참조
int * prats = &rats;  // prats는 포인터

rodents나 *prats를 rats와 서로 바꾸어 사용할 수 있고, &rodents나 prats를 &rats와 서로 바꾸어 사용할 수 있다.
```

참조를 먼저 선언하고 나중에 값을 지정할 수 없다. <br>
참조를 선언할 때에는 참조 변수를 함께 초기화해야 한다. (다만 매개변수로 넘길 때에는 넘길 때 초기화를 실행하게 되므로 가능하다.)

참조는 `const` 포인터와 상당히 비슷한데, 참조를 만들 때 반드시 초기화를 해야하고, 일단 어떤 특정 변수에 연결되면 그것을 고수해야 한다.
```cpp
int & rodents = rats;

int * const pr = &rats;

여기서 rodents는 *pr과 같은 역할을 한다.
```

### 함수 매개변수로서의 참조
참조는 주로 함수의 매개변수로 사용된다. <br>
어떤 함수에서 사용하는 변수의 이름을 그 함수를 호출한 프로그램(호출 함수)에 있는 어떤 변수의 대용 이름으로 만든다.
C++에 새로 추가된 이 기능은 오로지 `값`으로만 전달하는 C로부터 탈피하는 것이다.

`값`으로 전달하는 C에서, 피호출 함수는 호출 함수가 건네주는 값의 복사본을 대상으로 작업한다. <br>
물론 C는 `포인터`를 사용하여 값으로 전달하는 것에 따른 제약을 극복한다.

```cpp
값으로 전달할 때에는?
2개의 변수, 2개의 이름 times 와 x

void sneezy(int x);
int main()
{
	int times = 20;
	sneezy(times);
}

참조로 전달할 때에는?
1개의 변수, 2개의 이름 times, x

void grumpy(int& x);
int main()
{
	int times = 20;
	grumpy(times);
}
```

대표적으로 `swapping`함수는 호출 함수에 있는 변수들의 값을 바꿀 수 있어야 한다. <br>
`값`으로 전달되는 변수들의 경우에는 원본을 쓰지 않고 복사본의 내용만 서로 교화하고 함수를 종결하기 때문에 원하는 대로 작동하지 않는다. <br>
변수를 `참조`로 전달하면, 그 함수는 데이터의 `원본`을 가지고 작업할 수 있게 된다.

참조 매개변수는 구조체나 클래스와 같이 덩치 큰 데이터를 다룰 때에나 유익하다.


### 임시 변수, 참조 매개변수, const
C++은 실제 매개변수와 참조 매개변수가 일치하지 않을 때 `임시 변수`를 생성할 수 있다. <br>
최근의 C++은 매개변수가 `const 참조`일 경우에만 이것을 허용한다.

아래의 케이스는 `임시 변수`를 생성하게 된다.
- 실제 매개변수가 올바른 데이터형이지만 lvalue가 아닐 때
- 실제 매개변수가 잘못된 데이터형이지만 올바른 데이터형으로 변환할 수 있을 때

`lvalue`란 참조가 가능한 데이터 객체다. <br>
- 변수
- 배열의 원소
- 구조체의 멤버
- 참조
- 역참조 포인터

`일반 상수`와 여러 개의 항으로 이루어진 표현식은 `lvalue`가 아니다.

```cpp
double refcube(const double& ra)
{
	return ra * ra * ra;
}

double side = 3.0;
double * pd = &side;
double & rd = side;
long edge = 5L;
double lens[4] = {2.0, 5.0, 10.0, 12.0};

double c1 = refcube(side); // ra는 side
double c2 = refcube(lens[2]); // ra는 lens[2]
double c3 = refcube(rd); // ra는 rd이며 side
double c4 = refcube(*pd); // ra는 *pd이며 side
double c5 = refcube(edge); // ra는 임시 변수 (타입이 다르다.)
double c6 = refcube(7.0);  // ra는 임시 변수
double c7 = refcube(side + 10.0); // ra는 임시 변수
```

- 데이터형이 일치하지 않을 때
- 데이터형은 일치하지만, 이름을 가지고 있는 데이터 객체가 아닐 때`(lvalue 가 아니라는 뜻)`

이러한 경우에는 컴파일러가 `익명의 임시 변수`를 만들고 ra로 하여금 그것을 참조하게 한다. <br>
임시 변수는 함수가 호출되어 있는 동안 유지되지만, 그 후에 컴파일러는 그것을 마음대로 없앨 수 있다.

```
함수 호출 실제 매개변수가 lvalue 가 아니거나, 그에 대응하는 const 참조 매개변수의 데이터형과 일치하지 않을 때
C++은 정확한 데이터형의 익명 변수를 생성하고, 그 익명 변수에 함수 호출 실제 매개변수의 값을 대입하고,
매개변수가 그 익명 변수를 참조하게 된다.
```

#### 가능하면 const를 사용하자.
```
참조 매개변수를 상수 데이터에 대한 참조로 선언하는 이유는?

1. const를 사용하면, 실수로 데이터 변경을 일으키는 프로그래밍 에러를 막을 수 있다.
2. 원형에 const를 사용하면, 함수가 const와 const가 아닌 실제 매개변수를 모두 처리할 수 있지만,
   원형에 const를 생략한 함수는 const가 아닌 데이터만 처리할 수 있게 된다.
3. const 참조를 사용하면, 함수가 자신의 필요에 따라 임시 변수를 생성하여 사용할 수 있게 된다.
```

C++11은 `rvalue`참조라고 부르는 2번째 종류의 참조를 소개하는데, <br>
`rvalue`를 참조할 때 사용할 수 있으며, `&&`를 사용하여 다음과 같이 선언한다.
```cpp
double && rref = std::sqrt(36.00); // double & 은 허용되지 않는다.
double j = 15.0;
double && jref = 2.0 * j + 18.5;   // double & 은 허용되지 않는다.

std::cout << rref << '\n';         // 6.0 출력
std::cout << jref << '\n';         // 48.5 출력
```

`rvalue`참조는 라이브러리 디자이너로 하여금 특정 기능을 더욱 효율적으로 구현할 수 있도록 돕기 위하여 소개되었다. <br>
`move semantic`를 구현하기 위해서 `rvalue`참조가 어떻게 사용되었는지를 살펴볼 수 있다. <br>
단일 `&`을 사용하여 선언하는 경우는 `lvalue`참조라고 부른다.

### 구조체에 대한 참조
`참조`는 C++의 사용자 정의 데이터형인 구조체나 클래스를 다루는 데 아주 유용하게 사용된다. <br>
참조는 기본 `built-in`데이터 타입보다는 주로 사용자 정의 데이터형에 사용하기 위해 도입된 것이다.

기본 데이터형의 변수에 대한 참조를 선언할 때와 마찬가지로 구조체 매개변수를 선언할 때 `참조 연산자 &`를 앞에 붙이면 된다. <br>
만약 구조체를 변경하지 않으려면 `const`를 붙이면 된다.

### 왜 참조를 리턴하는가?
```cpp
double m = sqrt(16.0);
cout << sqrt(25.0);

첫 번째 구문에서는 결과 값인 4.0은 임시 장소에 복사된다.
그 다음에 임시 장소에 있는 값을 m으로 복사된다.

두 번째 구문에서 결과 값인 5.0은 임시 장소에 복사된 다음
그 임시 장소의 내용들이 cout로 전달된다.

free_throws& accumulate(free_throws& target, const free_throws& source)
{
	target.attempts += source.attempts;
	target.made += source.made;
	set_pc(target);
	return target;
}

dup = accumulate(team, five);

accumulate()가 어떤 구조체에 대한 레퍼런스 대신에 구조체 자체를 리턴한다면?
전체 구조체를 임시 장소에 복사하고 그 복사한 것을 dup에 복사할 것이다.

하지만, 참조를 리턴하게 되면 team은 직접적으로 dup에 복사되기 때문에 보다 효율적인 방법이 될 수 있다.
```

참조를 리턴하는 함수는 실제로 참조가 변수에 대한 `alias(별칭)파일`이다.


### 참조를 리턴할 때 주의할 점
함수가 종료할 때 수명이 함께 끝나는 메모리 위치에 대한 참조를 리턴하지 않도록 조심하는 것이다.

아래와 같은 코드는 사용하지 말아야 한다.